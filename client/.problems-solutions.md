# SO, This will be the bugs, problems, solving notes and solutions journaling ??

## [...Previous Problems]

## Problem 1 : Merging Todo_Schema & Todo_Subtasks_Schema

- Objective:
  Actually we want to merge todo_schema and todo_subtasks_schema data's of a specific user where two `todo_schema.data.id` is linking reference for `todo_subtask_data.todoId` where we can say todo_data id equals to subtask_data [{todoId:todo.id,...other}]. so on final : fullTodos = [{...todo.data,subtasks:[...todoIdLinkedSubtasks]}]

- Research:
  So, i found out to methods of merging: 1) Backend Database Aggregation & 2) Frontend State Filtering

  - Frontend :

    1. Filtering & merging functions based on the todo.id & subtask.todoId

    ```tsx
    // This Methods is parameters specific todos
    ```

    2. Double Layer Component Mapping

    ```tsx
       return todo.length>0 && todo.map((todo)) => {
        <Element1>
        {
          subtask.filter((sTask)=>sTask.todoId == todo.id)
          .map((_)=>{
            return <Element1> </Element2>
          })
        }
        </Element2>
        }
    ```

    - Issues

      1. ⚙️ Issues Faced:
      2. Subtasks not rendering when todos are empty or async data not yet loaded.
      3. Infinite re-renders if merge function is defined inside the component.
      4. Performance hit for large lists (double `.map()` and `.filter()` usage).

    - ✅ Solutions:
      1. Use useMemo or precompute merged data in Redux / Zustand store.
      2. If backend aggregation possible, prefer $lookup in MongoDB.
      3. Use stable keys and memoized components to avoid re-renders.
