# SO, This will be the bugs, problems, solving notes and solutions journaling ??

## [...Previous Problems]

## Problem 1 : Todo_Schema & Todo_Subtask_Schema POST at Once : 1

- @FIXES
- @todoId
  - This array object {...prev,user,todoId}, as you know showing relation
  - on different shchema is hard so we gonna add user:user.id ("User") and
  - todoId:todo.id ("Todo") Schemas.
  - Just added is `todoId` for showing relation of which todo_schema.data['id']
  - matches for TodoSubtask_schema.data.['id'], hence we can filterout data on
  - the given `.id`
- @todoId_PROCESS_CLIENT_BACKEND_DATABASE
  1.  Initiate Backend
  - a. create xyz todo. hold subtask creation
  - b. todo.controller.create => res ({ message:"", \_justCreatedTodoId :
  - abcd })
- 2.  Inititate Client
  - a. Axios<POST> : todo necessities hold form<todo> state.
  - b. Backend : store(somewhere randomly), todo.controller.create: response =>
  - response.data.\_justCreatedTodoId
  - c. store todo response '\_justCreatedTodoId' value somewhere randomly
  - d. Axios<PUT> : Check if todo. response.status matches Request
  - TodoSubtask with data's adding with each data =>
  - { ['todoId'] : todoId }
  - e. Wait State Form<Todo> until TodoSubtask.reponse.status matches, then
  - clear form with beautiful toasts

## Problem 2 : Merging Todo_Schema & Todo_Subtasks_Schema

- Objective:
  Actually we want to merge todo_schema and todo_subtasks_schema data's of a specific user where two `todo_schema.data.id` is linking reference for `todo_subtask_data.todoId` where we can say todo_data id equals to subtask_data [{todoId:todo.id,...other}]. so on final : fullTodos = [{...todo.data,subtasks:[...todoIdLinkedSubtasks]}]

- Research:
  So, i found out to methods of merging: 1) Backend Database Aggregation & 2) Frontend State Filtering

  - Frontend :

    1. Filtering & merging functions based on the todo.id & subtask.todoId

    ```tsx
    // This Methods is parameters specific todos
    ```

    2. Double Layer Component Mapping

    ```tsx
       return todo.length>0 && todo.map((todo)) => {
        <Element1>
        {
          subtask.filter((sTask)=>sTask.todoId == todo.id)
          .map((_)=>{
            return <Element1> </Element2>
          })
        }
        </Element2>
        }
    ```

    - Issues

      1. ⚙️ Issues Faced:
      2. Subtasks not rendering when todos are empty or async data not yet loaded.
      3. Infinite re-renders if merge function is defined inside the component.
      4. Performance hit for large lists (double `.map()` and `.filter()` usage).

    - ✅ Solutions:
      1. Use useMemo or precompute merged data in Redux / Zustand store.
      2. If backend aggregation possible, prefer $lookup in MongoDB.
      3. Use stable keys and memoized components to avoid re-renders.
